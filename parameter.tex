\section{Beschreibung und Analyse der XCS Parameter}\label{cha:parameter}

Motivation der Untersuchung der Parameter waren zum einen die vom Standard abweichenden Überwachungsszenarien und zum anderen der neuartige Algorithmus SXCS. Primäres Ziel dieses Kapitels ist es, darzustellen, dass die im Vergleich zu XCS bessere Qualität nicht von bestimmten Parametereinstellungen sondern vom Algorithmus selbst herrührt.\\ 

Anzumerken sei, dass alle Tests jeweils mit den in Tabelle~\ref{table:lcs_parameter} angegebenen Parameterwerten durchgeführt wurden und bei jedem Test jeweils nur der zu untersuchende Wert verändert wurde. Mit dem Ziel, synchronisierte und vergleichbare Daten zu haben, wurden die Tests in mehreren Etappen durchgeführt. Damit entsprechen die hier aufgeführten Testergebnisse nur den endgültigen Ergebnissen. Eine umfangreiche Untersuchung der Parameter war notwendig, da keine Vergleichsarbeiten mit der hier verwendeten Problemstellung existieren. Nicht auszuschließen ist bei diesem Vorgehen allerdings, dass es mehrdimensionale Kombinationen von Parameterwerten gibt, bei denen wesentliche bessere Ergebnisse erzielt werden, wobei dies bei den Tests nicht aufgefallen ist.\\

Liegt beim Test die erreichte Qualität unter der des zufälligen Algorithmus, ist beim Vergleich der Parameterwerte Vorsicht geboten. Die Ursache für die Verbesserung kann sein, dass der Algorithmus nicht besser lernt, sondern sich umgekehrt eher wie der zufällige Algorithmus verhält. Deswegen ist stets der Vergleich mit der Qualität des sich zufällig bewegenden Algorithmus durchzuführen.\\

Die Einstellungen der XCS Parameter der durchgeführten Experimente entsprechen weitgehend den Vorschlägen in~\cite{butz01algorithmic} ("`Commonly Used Parameter Settings"'). Eine Auflistung findet sich in Tabelle~\ref{table:lcs_parameter}. Nachstehend werden Parameter besprochen, die entweder in der Empfehlung offen gelassen sind, also klar vom jeweiligen Szenario abhängen, und solche, bei denen von der Empfehlung abgewichen wurde. Es wurden viele weitere Veränderungen getestet, in vielen Fällen war die Standardeinstellung jedoch passend. Abschluss der Besprechung der Parameter bietet Kapitel~\ref{uebersicht_parameter:sec} in dem eine komplette Übersicht über die wichtigsten Parameterwerte aufgelistet wird.\\


\subsection{Parameter \emph{max population N}}\label{sec:max_population_parameter}

Der Wert von \emph{max population N} bezeichnet die maximalen Größe der \emph{classifier set} Liste. Nach~\cite{butz01algorithmic} sollte \(N\) so groß gewählt werden, dass \emph{covering} nur zu Beginn eines Durchlaufs stattfindet, also die Anzahl der neu erstellten \emph{classifier} gegen Null geht. In Abbildung~\ref{neuerstellte_classifier_maxpop:fig} ist dies für das angegebene Säulenszenario ab einer Populationsgröße von etwa 512 erfüllt.\\

\begin{figure}[htbp]
\centerline{	
\includegraphics{neuerstellte_classifier_maxpop.eps}
}
\caption[Auswirkung der maximalen Populationsgröße auf die Anzahl der durch \emph{covering} neu erstellten \emph{classifier} (Säulenszenario)]{Auswirkung der maximalen Populationsgröße auf die Anzahl der durch \emph{covering} neu erstellten \emph{classifier} ({\bf Säulenszenario}, Zielobjekt mit einfacher Richtungsänderung, Geschwindigkeit 1, Agenten mit SXCS, \emph{tournament selection}, $p = 0,84$)}
\label{neuerstellte_classifier_maxpop:fig}
\end{figure}

Bei der Wahl eines geeigneten Werts für \(N\) spielen außerdem die Konvergenzgeschwindigkeit und die Laufzeit eine Rolle. Einen allgemein besten Wert für \(N\) gibt es nicht, denn er hängt insbesondere von der durch das Szenario und der durch die Länge des \emph{condition} Vektors gegebenen Möglichkeiten ab.\\

Die Zahl der Möglichkeiten wird wesentlich durch die Anzahl von verschiedenen \emph{classifier} bestimmt, die durch die \emph{covering} Funktion während eines bestimmten Laufs konstruiert werden können. Würde man beispielsweise weitere Zielobjekte auf das Feld setzen, könnten eine Reihe weiterer Situationen auftreten. So könnten z.B. Zielobjekte in zwei unterschiedlichen Richtungen in Sichtweite eines Agenten kommen.\\

Beim Szenario ohne Hindernisse fällt dagegen eine ganze Anzahl von Möglichkeiten heraus, was man in Abbildung~\ref{neuerstellte_classifier_maxpop_empty:fig} als Vergleich sehen kann. Selbiges stellt man im schwieriges Szenario fest (siehe Abbildung~\ref{neuerstellte_classifier_maxpop_difficult:fig}), hier gibt es zwar wesentlich mehr Hindernisse, jedoch sind sie immer in Sicht. Auch ist das Zielobjekt in relativ wenigen unterschiedlichen Situationen in Sicht. Beides verringert die Zahl der möglichen Situationen wieder.\\

Im Szenario mit zufällig verteilten Hindernissen (\(\lambda_{h} = 0,2\) und \(\lambda_{p} = 0,99\)) gilt dies jedoch nicht. Zwar ergeben sich aufgrund der groben Auflösung der Sensoren dort im Vergleich zum Säulenszenario kaum neue Situationen, die durch \emph{covering} abgedeckt werden müssen (siehe Abbildung~\ref{neuerstellte_classifier_maxpop_random:fig}), jedoch existieren auch genug hindernisfreie Freiräume.\\

\begin{figure}[htbp]
\centerline{	
\includegraphics{neuerstellte_classifier_maxpop_empty.eps}
}
\caption[Auswirkung der maximalen Populationsgröße auf die Anzahl der \emph{classifier} die durch \emph{covering} neu erstellt werden (leeres Szenario)]{Auswirkung der maximalen Populationsgröße auf die Anzahl der \emph{classifier} die durch \emph{covering} neu erstellt werden ({\bf leeres Szenario ohne Hindernisse}, Zielobjekt mit einfacher Richtungsänderung, Geschwindigkeit 1, Agenten mit SXCS, \emph{tournament selection}, $p = 0,84$)}
\label{neuerstellte_classifier_maxpop_empty:fig}
\end{figure}

\begin{figure}[htbp]
\centerline{	
\includegraphics{neuerstellte_classifier_maxpop_difficult.eps}
}
\caption[Auswirkung der maximalen Populationsgröße auf die Anzahl der \emph{classifier} die durch \emph{covering} neu erstellt werden (schwieriges Szenario)]{Auswirkung der maximalen Populationsgröße auf die Anzahl der \emph{classifier} die durch \emph{covering} neu erstellt werden ({\bf schwieriges Szenario}, Zielobjekt mit einfacher Richtungsänderung, Geschwindigkeit 1, Agenten mit SXCS, \emph{tournament selection}, $p = 0,84$)}
\label{neuerstellte_classifier_maxpop_difficult:fig}
\end{figure}

\begin{figure}[htbp]
\centerline{	
\includegraphics{neuerstellte_classifier_maxpop_random.eps}
}
\caption[Auswirkung der maximalen Populationsgröße auf die Anzahl der \emph{classifier} die durch \emph{covering} neu erstellt werden (Szenario mit zufällig verteilten Hindernissen)]{Auswirkung der maximalen Populationsgröße auf die Anzahl der \emph{classifier} die durch \emph{covering} neu erstellt werden ({\bf Szenario mit zufällig verteilten Hindernissen}, \(\lambda_{h} = 0,2\), \(\lambda_{p} = 0,99\), Zielobjekt mit einfacher Richtungsänderung, Geschwindigkeit 1, Agenten mit SXCS, \emph{tournament selection}, $p = 0,84$)}
\label{neuerstellte_classifier_maxpop_random:fig}
\end{figure}


\subsection{Overhead durch Populationsgröße}

Für den Overhead (d.h. die Zeit, die 8 Agenten mit zufälliger Bewegung benötigen) ergab sich eine mittlere Laufzeit von \(2,02\)s pro Experiment bei 500 Schritten (bzw. \(8,34\)s bei 2.000 Schritten). Dieser Wert wird von den Messwerten abgezogen und dort jeweils als "`Zeitdifferenz"' bezeichnet (siehe Abbildung~\ref{pillar_time_maxpop:fig}). Da im Wert noch der Overhead des XCS Algorithmus selbst enthalten ist, fällt der Wert erst relativ stark (bis etwa \(N = 256\) und konvergiert dann langsam (siehe Abbildung~\ref{linear_pop_time:fig}).\\

\begin{figure}[htbp]
\centerline{	
\includegraphics{pillar_time_maxpop.eps}
}
\caption[Auswirkung des Parameters \emph{max population N} auf Laufzeit (Säulenszenario)] {Darstellung der Auswirkung des Parameters \emph{max population N} auf die Laufzeit (Säulenszenario, Zielobjekt mit einfacher Richtungsänderung, Geschwindigkeit 1, Agenten mit SXCS, \emph{tournament selection}, $p = 0,84$)}
\label{pillar_time_maxpop:fig}
\end{figure}

\begin{figure}[htbp]
\centerline{	
\includegraphics{linear_pop_time.eps}
}
\caption[Verhältnis Laufzeit zu \emph{max population N} (Säulenszenario)] {Darstellung der Auswirkung des Parameters \emph{max population N} auf das Verhältnis der Laufzeit zu \(N\) (Säulenszenario, Zielobjekt mit einfacher Richtungsänderung, Geschwindigkeit 1, Agenten mit SXCS, \emph{tournament selection}, $p = 0,84$)}
\label{linear_pop_time:fig}
\end{figure}

Wie im vorherigen Abschnitt gesehen, sind die wichtigsten \emph{classifier}  mit Populationsgröße 512 (bzw. 256 im leeren und im schwierigen Szenario) bereits abgedeckt und eine Erhöhung der Populationsgröße schlägt sich negativ auf die Laufzeit nieder. Da den Agenten das Szenario unbekannt ist, wird für alle Szenarien deshalb derselbe Wert benutzt. Alles in allem scheint somit \(N = 512\) die beste Parametereinstellung zu sein, was Laufzeit und \emph{covering} betrifft.\\

Die Tests liefen auf einem T7500 mit \(2,2\) GHz in einem einzelnen Thread. Als Vergleich hierzu wurde auch der Einfluss der Torusgröße auf die Laufzeit betrachtet. Dabei wurden die Ergebnisse des einfachsten Falls (ein Torus mit der Größe 12x12, 8 SXCS Agenten, einem Zielobjekt mit einfacher Richtungsänderung und Geschwindigkeit 1) von den anderen Fällen (Sekunden und \(144\) Felder) abgezogen.\\

Wie in Abbildung~\ref{time_map_size_correlation:fig} zu sehen, ist der Einfluss auf die Laufzeit im getesteten Bereich (16x16 bis 64x64) linear mit der Anzahl der Felder (mit Ausnahme des Ausreißers bei 16x16) und ohne wesentliche Bedeutung.\\

\begin{figure}[htbp]
\centerline{	
\includegraphics{time_map_size_correlation.eps}
}
\caption[Auswirkung der Torusgröße auf die Laufzeit (Säulenszenario)] {Darstellung der Auswirkung der Torusgröße auf die Laufzeit (Säulenszenario, Zielobjekt mit einfacher Richtungsänderung, Geschwindigkeit 1, SXCS Agenten, \emph{tournament selection}, $p = 0,84$)}
\label{time_map_size_correlation:fig}
\end{figure}



\subsection{Zufällige Initialisierung der \emph{classifier set} Liste}\label{sec:random_init}

Normalerweise werden XCS Systeme mit leeren \emph{classifier set} Listen initialisiert. Als Option wird jedoch auch eine zufällige Initialisierung erwähnt \cite{Butz2006}, bei der zu Beginn die \emph{classifier set} Liste mit mehreren \emph{classifier} mit zufälligen \emph{action} Werten und \emph{condition} Vektoren gefüllt wird. Dort wird aber auch angemerkt, dass sich beide Varianten in ihrer Qualität nur wenig unterscheiden. Da zum einen ein gewisser Zeitaufwand nötig ist, die Liste zu füllen und zum anderen nicht sichergestellt ist, dass die generierten \emph{classifier} in dem jeweiligen Szenario überhaupt aktiviert werden können, scheint es sinnvoll zu sein, mit einer leeren \emph{classifier set} Liste zu starten.\\

Dies bestätigen auch Tests, in denen man die Anzahl durch \emph{covering} neu erstellter \emph{classifier} mit zufällige Initialisierung der \emph{classifier set} Liste (Abbildung~\ref{neuerstellte_classifier_maxpop_not_initialized:fig}) mit der Anzahl ohne Initialisierung (Abbildung~\ref{neuerstellte_classifier_maxpop:fig}) verglichen hat. Hier erkennt man, dass durchgehend etwas mehr \emph{classifier} generiert werden. Dies sieht man auch beim direkten Vergleich der insgesamt erstellten \emph{classifier} in Abbildung~\ref{erstellte_classifier_total:fig}.\\

Von der Qualität her erreicht die Variante mit initialisierter Liste minimal schlechtere Werte. Die Begründung ist, dass in der Liste auch eine Reihe von \emph{condition} Vektoren generiert werden, die nie auftreten. Diese müssen dann vom XCS erst erkannt und entfernt werden. Aus diesen Gründen werden alle Agenten mit leerer Liste starten.\\

\begin{figure}[htbp]
\centerline{	
\includegraphics{neuerstellte_classifier_maxpop_not_initialized.eps}
}
\caption[Auswirkung der maximalen Populationsgröße auf die Anzahl der \emph{classifier}, die durch \emph{covering} neu erstellt werden (Säulenszenario, ohne Initialisierung der \emph{classifier set} Liste)]{Auswirkung der maximalen Populationsgröße auf die Anzahl der \emph{classifier}, die durch \emph{covering} neu erstellt werden (Säulenszenario, Zielobjekt mit einfacher Richtungsänderung, Geschwindigkeit 1, Agenten mit SXCS, mit Initialisierung der \emph{classifier set} Liste, \emph{tournament selection}, $p = 0,84$))}
\label{neuerstellte_classifier_maxpop_not_initialized:fig}
\end{figure}


\begin{figure}[htbp]
\centerline{	
\includegraphics{erstellte_classifier_total.eps}
}
\caption[Auswirkung der maximalen Populationsgröße auf die Anzahl der \emph{classifier}, die durch \emph{covering} neu erstellt werden (Säulenszenario, ohne Initialisierung der \emph{classifier set} Liste)]{Auswirkung der maximalen Populationsgröße auf die Anzahl der \emph{classifier}, die durch \emph{covering} neu erstellt werden (Säulenszenario, Zielobjekt mit einfacher Richtungsänderung, Geschwindigkeit 1, Agenten mit SXCS, ohne Initialisierung der \emph{classifier set} Liste, \emph{tournament selection}, $p = 0,84$))}
\label{erstellte_classifier_total:fig}
\end{figure}


\subsection{Parameter \emph{accuracy equality} $\epsilon_{0}$}\label{epsilon0:sec}

Der Parameter \(\epsilon_{0}\) gibt an, unter welchem \emph{reward prediction error} Wert ein \emph{classifier} als exakt gilt (und als \emph{subsumer} auftreten kann, siehe Kapitel~\ref{subsummation:sec}) und wie stark dieser Wert in die Berechnung der \emph{fitness} einfließt.\\

In der Literatur~\cite{butz01algorithmic} wird als Regel genannt, dass der Wert auf etwa 1\% des Maximalwerts des \emph{base reward} Werts (\(\rho\)) gesetzt werden soll. Dieser ist beliebig wählbar und hat lediglich ästhetische Auswirkungen. Somit wird dieser auf \(1,0\) und \(\epsilon_{0}\) auf \(0,01\) gesetzt.\\


\subsection{Parameter \emph{GA threshold} $\theta_{\mathrm{GA}}$}\label{threshold:sec}

Der \emph{GA threshold} Parameter gibt an, ab wie groß der zeitliche Abstand zwischen zwei Aufrufen des genetischen Operators ist. Als Vergleichswerte werden hierbei zum einen der aktuelle Zeitpunkt und zum anderen der Durchschnittswert der Erstellungszeitpunkte der \emph{classifier} aus dem jeweiligen \emph{action set} benutzt. Die in der Einleitung erwähnte (siehe Kapitel~\ref{abgrenzung:sec}), vergleichbare Arbeit~\cite{1102281} benutzt einen deutlich größeren Wert für \(\theta_{\mathrm{GA}}\) (10.000) als andere Arbeiten aus der Literatur. Dies wird damit begründet, dass dort eine wesentlich größere Menge an Schritten zum Ziel benötigt als üblich. Allerdings liefen die dortigen Tests auch über eine wesentlich größere Zahl von Schritten (500.000).\\

Tests (siehe Abbildung~\ref{theta:fig}) zeigten keinen Vorteil in diesem Zusammenhang, weshalb der Standardwert am oberen Ende des vorgeschlagenen Bereichs \(\theta_{\mathrm{GA}} = 50,0\) benutzt wird. Zwar wurden mit \(\theta_{\mathrm{GA}} = 25,0\) etwas bessere Werte erzielt, dies ist jedoch erst in der letzten Testetappe zum Vorschein gekommen und konnte aus Zeitgründen nicht in alle anderen Tests wieder integriert werden. Soweit nicht anders angegeben wird also der Wert \(50,0\) benutzt.\\

\begin{figure}[htbp]
\centerline{	
\includegraphics{theta.eps}
}
\caption[Vergleich verschiedener Werte für $\theta_{\mathrm{GA}}$ (Säulenszenario)]{Vergleich verschiedener Werte für $\theta_{\mathrm{GA}}$ (Säulenszenario, SXCS Agenten, \emph{tournament selection}, $p = 0,84$)}
\label{theta:fig}
\end{figure}



\subsection{Parameter \emph{reward prediction discount} $\gamma$}

In der Literatur in~\cite{butz01algorithmic} wird ein Standardwert von \(\gamma = 0,71\) genannt, es seien je nach Szenario aber auch größere und kleinere Werte möglich. Ein höherer Wert für \(\gamma\) bedeutet, dass die Höhe des Werts, der über \emph{maxPrediction} weitergegeben wird, mit zeitlichem Abstand zur ursprünglichen Bewertung mit einem \emph{base reward} Wert, weniger schnell abfällt, wodurch eine längere Verkettung von \emph{base reward} Werten möglich ist. Umgekehrt führen zu hohe Werte für \(\gamma\) zu einer positiven Bewertung von \emph{classifier} die am Erfolg womöglich gar nicht beteiligt waren, was sich negativ auf die Qualität auswirken kann, da diese etwas Falsches lernen.\\

Abbildung~\ref{prediction_discount:fig} zeigt einen Vergleich der Qualität bei unterschiedlichen Werten für \(\gamma\) beim XCS Algorithmus im Säulenszenario. "`Intelligent"' und "`Einfache Richtungsänderung"' beziehen sich jeweils auf die Eigenschaften des Zielobjekts. Ein konkretes Muster ist nicht zu erkennen, nur im Fall von \(\gamma = 1,0\) gibt es einen deutlichen Abfall der Qualität. Das erscheint auch logisch, da dies bei XCS bedeuten würde, dass jede \emph{action set} Liste alle \emph{reward} Werten in voller Stärke sukzessive an alle weitergibt. Da sonst keine besonderen Fluktuationen zu beobachten sind, wird, wie vorgeschlagen, hier jeweils \(\gamma = 0,71\) verwendet wird.\\

\begin{figure}[htbp]
\centerline{	
\includegraphics{prediction_discount.eps}
}
\caption[Auswirkung verschiedener \emph{reward prediction discount} $\gamma$ Werte auf die Qualität]{Auswirkung verschiedener \emph{reward prediction discount} $\gamma$ Werte auf die Qualität (Säulenszenario, Agenten mit XCS, \emph{best selection})}
\label{prediction_discount:fig}
\end{figure}

Die Beobachtung ist ein Hinweis darauf, dass die Weitergabe des \emph{base reward} Werts grundsätzlich erfolgen sollte, jedoch sonst keinen Einfluss hat, also wahrscheinlich keine zusammenhängenden Ketten von Aktionen gebildet werden. Diese Überlegung unterstreicht auch die Überlegungen die zur SXCS Variante gemacht wurden (siehe Kapitel~\ref{sxcs_variant:sec}): Im Überwachungsszenario kann das Finden von "`Wegen"' auf diese Weise (wie beim einführenden Beispiel zum \emph{multi step} Verfahren in Kapitel~\ref{multi_step_intro:sec}) nicht zum Erfolg führen, da dem Szenario die Markow-Eigenschaft fehlt. Mit einer Erweiterung der Sensoren, prägnanteren Strukturen der Hindernisse und Aufenthaltswahrscheinlichkeiten des Zielobjekts auf dem Torus mit hoher Varianz würde dies vielleicht besser aussehen, der einzige Ansatz, dessen Erfolg in dieser Arbeit gezeigt wird, ist allerdings SXCS.\\




\subsection{Parameter Lernrate $\beta$}\label{sec:learnrate_parameter}

Die Lernrate bestimmt u.a., wie stark ein ermittelter \emph{reward} Wert den \emph{reward prediction}, \emph{reward prediction error} und \emph{fitness} Wert bei jeder Aktualisierung beeinflusst.\\ 

In~\cite{1102281} wurde ein unter dem Standardwert liegender Wert von \(\beta = 0,02\) benutzt. Als Begründung wurde angegeben, dass dynamische Multiagentensysteme in vielerlei Hinsicht nur über Wahrscheinlichkeiten beschrieben werden können und somit der Lernvorgang eher vorsichtig vonstatten gehen sollte.\\

Vergleichende Tests (siehe Abbildung~\ref{pillar_learning_rate_quality:fig}) zeigen für SXCS einen Optimalwert zwischen \(0,01\) und \(0,1\) an, größere Werte scheinen den Lernprozess deutlich zu schaden. Interessanterweise steigt für XCS bei großen Werten für \(\beta\) die Qualität deutlich an. Woher dieser Anstieg kommt, müsste näher untersucht werden. Da aber große Werte für \(\beta\) die Vergleichbarkeit in Frage stellen, soll sich hier auf niedrige Werte beschränkt werden.\\

Später in Kapitel~\ref{xcs_difficult_scenario:sec} wird auch noch die Lernrate im schwierigen Szenario untersucht, bei dem sich höhere Lernraten als vorteilhaft herausstellen.\\

\begin{figure}[htbp]
\centerline{	
\includegraphics{lernrate_beta.eps}
}
\caption[Auswirkung des Parameters Lernrate $\beta$ auf Qualität (Säulenszenario)] {Auswirkung des Parameters Lernrate $\beta$ auf die Qualität (Säulenszenario, Agenten mit XCS und SXCS Algorithmus, \emph{best selection})}
\label{pillar_learning_rate_quality:fig}
\end{figure}



\subsection{Parameter \emph{tournament factor p}}\label{tournament_factor_test:sec}

Beim Vergleich zwischen \emph{best selection} (in einer andauernden \emph{exploit} Phase) und einer abwechselnden \emph{explore}/\emph{exploit} Phase (mit \emph{tournament selection} in der \emph{explore} Phase und \emph{best selection} in der \emph{exploit} Phase), zeigt Abbildung~\ref{vergleich_tournament_factor_best:fig} deutlich, dass im Säulenszenario die Auswahlart \emph{best selection} (entspricht \emph{tournament selection} mit \(p = 1,0\)) die bessere Wahl für SXCS ist.\\

Für das Szenario mit Hindernissen (mit $\lambda_{p} = 0,99$ und $\lambda_{h} = 0,2$) sieht die Sache jedoch anders aus. Hier spielen die Zahl der blockierten Bewegungen mit eine wesentliche Rolle. In den Tests stieg der Anteil der blockierten Bewegungen von etwa 40\% (bei \(p = 0,6\)) auf bis über 70\% (\(p = 1,0\)).\\

\begin{figure}[htbp]
\centerline{	
\includegraphics{vergleich_tournament_factor_best.eps}
}
\caption[Vergleich verschiedener \emph{tournament factor} Werte mit \emph{best selection}, SXCS]{Vergleich verschiedener \emph{tournament factor} Werte mit \emph{best selection} (Säulenszenario und Szenario mit zufällig verteilten Hindernissen mit ($\lambda_{p} = 0,99$ und $\lambda_{h} = 0,2$), {\bf SXCS Agenten})}
\label{vergleich_tournament_factor_best:fig}
\end{figure}

Ähnliches kann man in Abbildung~\ref{vergleich_tournament_factor_best_xcs:fig} beim XCS Agenten feststellen. Hier erstreckt sich der Anteil der blockierten Bewegungen ebenfalls bis über 70\% für \(p = 1,0\), wenn auch für \(p = 0,6\) der Wert etwas unter 30\% lag. Hier ist möglicherweise eine explorativere Variante von Vorteil, dies wird in Kapitel~\ref{analysis_random_scenario_xcs:sec} näher untersucht.\\

\begin{figure}[htbp]
\centerline{	
\includegraphics{vergleich_tournament_factor_best_xcs.eps}
}
\caption[Vergleich verschiedener \emph{tournament factor} Werte mit \emph{best selection}, XCS]{Vergleich verschiedener \emph{tournament factor} Werte mit \emph{best selection} (Säulenszenario und Szenario mit zufällig verteilten Hindernissen mit ($\lambda_{p} = 0,99$ und $\lambda_{h} = 0,2$), {\bf XCS Agenten})}
\label{vergleich_tournament_factor_best_xcs:fig}
\end{figure}

Für den \emph{tournament factor} selbst konnte hier kein Optimalwert gefunden werden, je nach Szenario muss eine eigene Auswahlart gefunden werden. In einigen Szenarien wird ein Wert von \(p = 0,84\) verwendet werden, welcher sich erfahrungsgemäß als brauchbar für Vergleiche herausgestellt hat, auch wenn er nicht optimal ist.\\


\subsection{Übersicht über alle Parameterwerte}\label{uebersicht_parameter:sec}

In Tabelle~\ref{table:lcs_parameter} findet sich die Aufstellung der wesentlichen Parameter für die Simulation. In der dritten Spalte sind jeweils die Standardwerte aus der Literatur~\cite{butz01algorithmic} angegeben, nähere Erläuterungen finden sich in den jeweils aufgeführten Verweisen zu den einzelnen Kapiteln.\\

\begin{table}[ht]
\caption{Verwendete Parameter (soweit nicht anders angegeben) und Standardparameter}
\centering
\begin{tabular}{c c c}
\hline\hline
Parameter & Wert & Standardwert~\cite{butz01algorithmic}\\ [0.5ex]
\hline
max population \(N\) & \textbf{512} (siehe Kapitel~\ref{sec:max_population_parameter}) & [\emph{je nach Szenario}]\\
max value \(\rho\) & \textbf{1,0} (siehe Kapitel~\ref{epsilon0:sec}) & [10.000]\\
fraction mean fitness \(\delta\) & 0,1 & [0,1]\\
deletion threshold \(\theta_{\mathrm{del}}\) & 20,0 & [\(\sim\) 20,0]\\
subsumption threshold \(\theta_{\mathrm{sub}}\) & 20,0 & [20,0+]\\
covering \(\#\) probability \(P_{\#}\) & 0,33 & [\(\sim\) 0,33]\\
GA threshold \(\theta_{\mathrm{GA}}\) & 50 (siehe Kapitel~\ref{threshold:sec}) & [25-50]\\
mutation probability \(\mu\) & \(0,05\) & [0,01-0,05]\\
prediction error reduction & 0,25 & [0,25]\\
fitness reduction & \(0,1\) & [0,1]\\

reward prediction init \(p_{i}\) & 0,01 & [\(\sim\) 0]\\
prediction error init \(\epsilon_{i}\) & 0,0 & [0,0]\\
fitness init \(F_{i}\) & \(0,01\) &  [0,01]\\
condition vector & \textbf{leer} (siehe Kapitel~\ref{sec:random_init}) &  [\emph{zufällig oder leer}]\\
numerosity & 1 & [1]\\
experience & 0 & [0]\\

accuracy equality \(\epsilon_{0}\) & \textbf{0,01} (siehe Kapitel~\ref{epsilon0:sec}) & [\emph{1\% des größten Werts}]\\
accuracy calculation \(\alpha\) & 0,1 & [0,1]\\
accuracy power \(\nu\) & 5,0 & [5,0]\\
reward prediction discount \(\gamma\) & 0,71 & [0,71]\\

learning rate \(\beta\) & \textbf{0,01 - 0,2} (siehe Kapitel~\ref{sec:learnrate_parameter}) & [0,1-0,2]\\

exploration probability & 0,5 (siehe Kapitel~\ref{subsummation:sec}) & [\(\sim\) 0,5]\\
tournament factor & 0,84 (siehe Kapitel~\ref{tournament_factor_test:sec}) & [-]\\ [0.5ex]

\hline
\end{tabular}
\label{table:lcs_parameter}
\end{table}
